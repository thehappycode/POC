# Overview of encryption, digital signatures, and hash algorithms in .NET

Trong bài học hôm nay, chung ta sẽ overview các encryption methods và practices được hỗ trợ bởi .NET, gồm cả ClickOnce manifests.

## Introduction to cryptography

Pubic network là giao tiếp không được bảo vệ trên mạng internet. Việc giao tiếp trên networks rất dễ bị đọc hoặc chỉnh sửa bởi bên bên thứ ba (third parties). Cryptography giúp bảo vệ dữ liệu của người đọc (viewer), nhà cung cấp xác định được dữ liệu đã bị chỉnh sửa, và giúp việc giao tiếp trơ nên an toàn trên cả những kênh không được bảo vệ. Ví dụ, dữ liệu được mã hóa (encrypted) bằng cách sử dụng cryptographic algorithm, và dữ liệu đó được chuyển đi, sau đó được bên nhận giải mã (decrypted). Nếu third party chặn dữ liệu đã mã hóa, dữ liệu đó cũng khó biết được cách giả mã (decipher).

Trong .NET, những classes trong namespace `System.Security.Cryptography` quản lý việc cryptography của bạn. Đôi khi chúng được đóng gói (wrappers) triển khai trong hệ điều hành (OS), trong khi những classes khác sẽ bị quản lý việc triển khai. Bạn không cần phải là các chuyên già (expert) về cryptography mới có thể sử dụng được các classes này. Khi bạn tạo một new instance của một encryption algorithm classes, keys are autogenerated rất dễ để sử dụng, và các properties mặc định chắc chắc safe và secure.

## Cryptographic Primitives

Trong một tình huống nơi mà cryptography được sử dụng, có 2 bên (Alice và Bod) giao tiếp với nhau trên một kênh nosecure. Alice và Bob muốn đảm bảo (ensure) bất kỳ ai khác lắng nghe (listening) cũng không thể hiểu được. Bởi vì Alice và Bob đang giao tiếp từ xa (remote locations), Alice muốn chắc chắn thông tin cô ấy nhận từ Bob đã không bị bất kỳ ai thay đổi (modifier) trong suốt quá trình trao đổi (transmission). Thêm nữa, cô ấy cũng muốn chắc thông tin đó là từ Bob chứ không phải đến từ bất kỳ người nào mạo danh Bob.

Crytography được sử dụng vì các mục đích sau:

- Confidentiality: Giúp bảo vệ danh tính người dùng (user's identity) hoặc dữ liệu đến khi được đọc.
- Data integrity: Giúp bảo vệ dữ liệu từ không bị thay đổi.
- Authentication: Đảm bảo dữ liệu gốc từ một bên cụ thể.
- Non-repudiation: Ngăn chặn một bên cụ thể từ chối thông điệp mà họ đã gửi.

Từ những mục đích trên, bạn có thể kết hợp sử dụng nhiều algorithms và practices bằng cryptographic primitives để tạo ra một cryptography scheme. Bảng bên dưới là danh sách các cryptographic primitives.

| Cryptographic primitive                         | Use                                                                                                                                                                                                            |
| :---------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Secret-key encryption (symmetric cryptography)  | Secret-key thực hiện việc chuyển đổi trên dữ liệu, giữ cho dữ liệu không thể bị đọc bởi third parties. Đây là kiểu mã hóa (encryption) sử dụng một sigle shared, secret-key dùng để encrypt và decrypt dữ liệu |
| Public-key encryption (asymmetric cryptography) | Public-key thực hiện việc chuyển đổi trên dữ liệu, giữ cho dữ liệu không thể bị đọc bởi third parties. Đây là kiểu mã hóa (encryption) sử dụng  một cặp public/private keys để encrypt và decrypt dữ liệu      |
| Cryptographic signing                           | Giúp xác nhận (verify) dữ liệu gốc từ chính xác một bên tạo bởi quá trình ký số (digital signature) duy nhất của bên đó. Quá trình sử lý sử dụng chức năng hash                                                |
| Cryptographic hashes                            | Ánh xạ dữ liệu (Maps data) có chiều dài bất kỳ luôn trả về một chuổi byte có chiều dài cố định. Hashes là duy nhất; Hai chuổi byte khác nhau sẽ không thể hash cùng một giá trị                                |

## Secret-Key Encryption

Secret-key encryption algorithms sử dụng một single secret key để encrypt và decrypt data. Bạn bắt buộc secure key, không được truy cập bởi unauthorized, bởi vì bất kỳ bên nào có key cũng có thể sử dụng để decrypt dữ liệu của bạn hoặc encrypt dữ liệu và tuyên bố đó là dữ liệu gốc từ bạn.

Secret-key encryption được quy vào là symmetric encryption bởi vì sử dụng cùng một key cho việc encryption và decryption. Secret-key encrytion algorithms rất nhanh (compared with public-key algorithms) và nó hoàn toàn tốt cho performing cryptographic transformations trên large streams of data. Asymmetric encrytion algorithms như RSA bị giới hạn bởi tính toán với lượng nhiều dữ liệu có thể encrypt. Symmetric encryption algorithms không tạo ra những vấn đề đó.

Secret-key algorithm mà một kiểu mã hóa khối (block cipher), nó được sử dụng để encrypt một block dữ liệu tại một thời gian. Block ciphers như Data Encryption Standard (DES), TripleDES, và Advanced Encryption Standard (AES) chuyển đổi một input block với  n bytes vào trong một output block của encrypted bytes. Nếu bạn muốn encrypt hoặc decrypt một chuổi bytes, bạn sẽ phải thực hiện từng block một. Bởi vì n nhỏ (8 bytes với DES và TripDES, 16 bytes [default], 24 bytes hoặc 32 bytes của AES), giá trị dữ liệu của một encrypted trên một block tại một thời gian sẽ lớn hơn n. Giá trị dữ liệu sẽ nhở hơn n khi ta tăng n trong quá trình xử lý.

Một simple của block cipher được gọi là electronic codebook (ECB) mode. ECB mode không bảo vệ nội dung, bởi vì nó không sử dụng initialization vector để khởi tạo một first plaintext block. Có một key k, một simple block cipher không sử dụng initialization vector khi encypt input block của plaintext vào trong output block khi mã hóa. Khi đó, nếu bạn duplicate blocks trong input plaintext stream của bạn, bạn sẽ có duplicate blocks in output cipertext stream. Khi duplicate output blocks thì các unauthorized users sẽ biết đây là weak encryption sử dụng algorithms, họ có thể tiến hành tấn công. ECB cipher mode rất dễ bị phân tích để khám phá key.

Block cipher classes được cung cấp trong base class library sử dụng default chaining mode được gọi là cipher-block chainning (CBC), bạn có thể thay đổi default này nếu bạn muốn.

CBC ciphers giải quyết hết các vấn đề của ECB ciphers bởi initialization vector (IV) để encrypt the first block of plaintext. Mỗi subsequence block của plaintext bên dưới sẽ thực hiện mã hóa kèm theo bitwise đã được mã hóa block trước đó. Mỗi một ciphertext block sẽ phụ thuộc vào tất cả các block trước đó. Nên khi sử dụng, những authorized user không thể sẻ dụng reverse-enginner một key.

Một cách để compromise data (lấy dữ liệu gốc) với mã hóa CBC cipher là thực hiện tìm kiếm toàn tất cả key. Điều này phụ thuộc vào kích thước của key khi sử dụng để thực hiện encryption, việc tìm kiếm tiêu tốn rất nhiều thời gian kể cả với những máy tính siêu nhanh. Kích thước key càng lớn thì càng khó để decipher và chi phí để giải mã càng cao nên gần như không khả thi trong thực tế.

Một bất lợi (disadvantage) của secret-key encryption là phải có sự đồng ý của hai bên về key và IV, và giao tiếp với 2 giá trị đó. IV sẽ có nội dung không bí mật và đùng để chuyển đổi plaintext với message. Tuy nhiên, key phải bắt buộc phải được giữ bí mật với unauthrized users. Bởi vì, key-secret encryption thường được dùng cùng với public-key encrytion để giao tiếp.

Giả sử Alice và Bob là 2 bên muốn giao tiếp với nhau trên kênh nosecure, họ sử dụng secret-key encryption theo luồng sau: Alice và Bob đồng ý sử dụng một algorithm (AES chẳn hạn) với một key và IV. Alice sẽ tạo một message và tạo một network stream (network email) để chuyển message. Tiếp theo, cô ấy sẽ encrypts text sử dụng key và IV, và chuyển encryption message và IV đến Bob trên mạng nội bộ. Bob nhận encrypted text và decrypts sử dụng IV và key đã thống nhất trước đó. Nếu trong quá trình chuyển, message bị chặn lại thì người chặn cũng không thể recover được message original, bởi vì họ không biết key. Trong kịch bản này, chỉ có key là được giữ bí mật. Trong thế giới thực, Alice và Bob sẽ tạo một secret key và sử dụng public-key (asymmetric) encryption và chuyển secret (symmetric) key đến bên khác. Thông tin về public-key encryption, sẽ được thấy trong mục tiếp theo.

.NET cung cấp classes để thực hiện secret-key encrytion algorithms sau:

- Aes
- HMACSHA256, HMACSHA384 và HMACSHA512

## Public-key Encryption

Public-key encryption sử dụng một `private key` bắt buộc phải giữa bí mật để để authentication users và một `public key` có thể public cho bất kỳ ai. Public key và private key có sự quan hệ (linked) về mặt toán học; data khi đã encrypted với public key chỉ có thể được decrypted với private key, và data được signed với private key thì chỉ có thể verified với public key. Public key có thể được cung cấp cho bất kỳ ai; nó được sử dụng dể encrypting data và chuyển đến người nắm giữ private key. Public-key cryptographic algorithms còn được biết đến là asymmetric algorithms bởi vì nó yêu cầu 1 key để encrypt data và yêu cầu môt key khác để decrypt data. Một quy tắc basic cryptographic là cấm (prohibits) là tái sử dụng key, và cả 2 keys phải là duy nhất trong mỗi communication session. Tuy nhiên, khi thực hành, asymmetric keys được tạo với thời gian sống rất lâu (long-lived).

Có hai bên (Alice và Bob) sử dụng public-key encryption như sau: Trước tiên, Alice tạo một cặp public/private key. Nếu Bob muốn chuyển đến Alice một encrypted message, anh ấy sẽ hỏi `public key` của cô ấy. Alice chuyển Bob `public key` của cô áy trên mạng nosecure network, và Bob sử dụng `public key` này để encrypt một message. Bob sẽ chuyển encrypted message sang cho Alice, và cô ấy sẽ decryptes nó bằng cách sử dụng `private key` của cô ấy. Nếu Bob nhận key của Alice trên kênh nosecure chanel, như public network, Bob có thể sẽ bị một cuộc tấn công trung gian (Bob is open to a man-in-the-middle attack). Khi đó, Bob bắt buộc phải xác nhận (verify) với Alice là anh ấy đã copy đúng `public key` của cố ấy.

Trong suốt quá trình trao đổi `public key` của Alice, một unauthorized agent (đại lý, tác nhân) có thể chặn để láy `public key`. Hơn nữa,  agent này cũng chặn encrypted message từ Bob. Tuy nhiên, agent không thể decrypt the message với public key. The message chỉ có thể được decrypted chỉ duy nhất với `private key` của Alice, mà `private key` này ko được trao đổi. Alice cũng không được sử dụng `private key` để encrypt một reply message và chuyển đến Bob, bời vì bấy kỳ ai với `public key` cũng có thể decrypt message. Nếu Alice muốn chuyển một message để phản hồi Bob, thì cô ấy sẽ hỏi Bob `public key` của anh ấy và encrypts message của cô ấy với `public key` của Bob. Khi đó Bob sẽ dùng `private key` của mình để decrypt message từ Alice.

Trong kịch bản (scenario) này, Alice và Bob sử dụng public-key encryption để trao đổi môt secret key (symmetric) và sử dụng secret-key encryption trong suốt session còn lại.

Đây là danh sách so sách chính thức giữa public-key và secret-key cryptgraphic algorithms

- Public-key cryptographic algorithms được sử dụng để **fix buffer size**, trong khi secret-key cryptographic algorithms được sử dụng để **variable-length buffer**.

- Public-key algorithms không thể sử dụng chain data cùng nhau trong streams trong khi secret-key thì có thể, bởi vì chỉ số lượng nhỏ data có thể được encrypted. Do do, asymmetric operations cũng không được sử dụng với các streaming model giống như symmetric operations.

- Public-key encryption có số lượng keyspace (khoảng giá trị của key) lớn hơn nhiều so với secret-key encryption. Do do, public-key encryption khó có thể bị tấn công bằng cách thử cố gắng vét cạn key.

- Public key dễ dàng sử dụng trong hệ thống phân tán, bởi vì chúng ta không cần phải bảo vệ, và có thể cung cấp key cho bất kỳ ai.

- Một số public-key algorithms (RSA và DSA, nhưng không phải Diffie-Hellman) được dùng để tạo digital signatures và có thể xác nhận (verify) được người gủi data.

- Public-key algorithms sẽ rất chậm (very slow) khi so sánh với secret-key algorithms, và nó không được designed để encrypt số lượng lớn data. Public-key algorithms chỉ hửu ích trong việc trao đổi số lượng nhỏ data. Như trường hơp, public-key encryption được dùng để encrypt key và `IV` của secret-key algorithm. Sau đó key và `IV` được trao đổi, secret-key encryption sử dụng trong suốt session còn lại.

.NET cung cấp các classes sau để thực hiện public-key algorithms:
- RSA
- ECDsa
- ECDiffieHellman
- DSA

RSA cho phép encryption và signing, nhưng DSA chỉ có thể được sử dụng trong signing. DSA nó không an toán bằng RSA, và lời khuyên của chúng tôi là dùng RSA. Diffie-Hellman có thể chỉ được sử dụng khi tạo key (key generation). Nhìn chung, public-key algorithms có nhiều giới hạn hơn trong việc chúng ta sử dụng private-key algorithms.

## Digital Signatures

Public-key algorithms có thể sử dụng cho mục đích digital signatures. Digital signatures dùng để xác thực định danh người gửi ((authentication the identity of a sender) và giúp bảo vệ tính toàn vẹn của dữ liệu (integrity of data). Sử dụng public key được tạo bởi Alice, dữ liệu được Alice tạo ra có thể được verify người gửi là Alice bằng cách só sánh digital signature từ Alice's data và Alice's public key.  

Sử dụng public-key cryptography để digital sign một message, trước tiên Alice phải áp dụng (applies) một hash algorithm lên message để tạo một message digest. Message digest là thỏa thuận (compact) và duy nhất (unique) trong việc miêu tả dữ liệu. Alice sau khi encrypts the message digest với private key của cô ấy, khi đó cô ấy là personal signature. Khi nhận message và signature, Bob decrypts the signature sử dụng public key của Alice để phục hồi (recover) message digest và hashes the message sử dụng đúng hash algorithm mà Alice dụng. Nếu message digest của Bob trùng khớp với message digest nhận được từ Alice, Bob cần phải chắc chắn message đó đến từ Alice sử dụng private key và dữ liệu sẽ không bị chỉnh sửa. Nếu Bob tin tưởng Alice là người sở hữu private key, và anh ấy biết message đến từ Alice.

.NET cung cấp các classes sau để thực hiện digital signature algorithms sau:

- RSA
- ECDsa
- DSA

## Hash Values

Hash algorithms map binary values có chiều bất kỳ (arbitrary length) thành smaller binary values có chiều dài cố định (fixed length) nó được biết đến là hash values. Một hash value là trình bày môt phần của dữ liệu (piece of data). Nếu bạn hash một đoạn văn (paragraph) của plaintext và thay đổi đổi một ký tự trong đoạn văn (paragraph), khi đó một subsequent hash sẽ tạo ra (produce) một giá trị khác. Nếu hash là cryptographically strong, giá trị sẽ thay đổi rất khác biệt. Ví dụ, nếu thay đổi một signle bit của message, một strong hash function có thể tạo ra output khác đến 50%. Nhiều input values có thể hash giống với output value. Tuy nhiên, về mặt tính toán thì không thể tìm thấy 2 input sau khi hash có giá trị giống nhau. 

Ta có 2 bên (Alice và Bob) có thể sử dụng hash function để đảm bảo tính toàn vẹn dữ liệu (integrity data). Họ  chọn một hash algorithm để sign messages của họ. Alice viết một message, và sau đó sẽ tạo một hash cho message đó bằng cách sử dụng giải thuật đã chọn (selected algorithm).

- Alice chuyển plaintext message và hashed message (digital signature) đến Bob. Bob nhận và hashes message và so sánh hash value của anh ấy với hash value mà anh ấy nhận từ Alice. Nếu hash value giống hệt nhau (identical), thì message không bị sửa đổi. Nếu hash values không giống hệt nhau (identical), message đã bị sửa đổi sau khi Alice viết nó.
  Thật không may, phương thức này không phải là nền tảng (establish) để authenticity người giử (sender). Bất kỳ ai cũng có thể mạo danh (impersonate) Alice và send một message đến Bob. Họ có thể sử dụng cùng một hash algorithm để sign message của họ, và sau tất cả, Bob chỉ có thể xác định (determine) message trùng khớp với signature. Đó là khuông mẫu của một man-in-the-middle attack.

- Alice chuyển plaintext message đến Bob trên một kênh công khai không an toàn (nonsecure public channel). Cô ấy chuyển hash message trên một kênh riêng tư an toàn (secure private channel). Bob nhận plaintext message, hashes nó, và so sánh nó có khác với hash message nhận được trên private channel. Nếu 2 hashes trùng khớp, Bob biết được 2 điều:
    - Message không bị chỉnh sửa.
    - Chức thực được người gửi message là Alice.
Khi hệ thống này làm việc, Alice có thể ẩn hash value gốc (original hash value) với tất cả các bên ngoại trừ Bob.

- Alice chuyển plaintext message đến Bob trên một kênh công khai không an toàn và cũng là kênh hash message của cô ấy công khai được phép đọc trên Website của chính cô ấy.
  Cách thức này ngăn chặn bất kỳ ai muốn chặn từ việc chỉnh sửa hash value. Mặc dù message và hash có thể được đọc bởi bất kỳ ai, hash value chỉ có thể được thay đổi bới chính Alice. Một người attack muốn mạo danh (impersonate) Alice phải được Website của Alice cho quyền truy cập.

Không như phương thức trước đó, bất kỳ ai cũng có thể chặn để đọc messages của Alices, bởi vì họ trao đổi (transmitted) plaintext. Đây là loại đảm bảo an toàn vì yêu cầu digital signature (message signing) và encryption.

.NET cung cấp các classes sau để thực hiện hashing algorithms

- SHA256
- SHA384
- SHA512

.NET cũng cung cấp MD5 và SHA-1. Nhưng giải thuật MD5 và SHA-1 đã tìm được cách giả mã nên không an toàn, và lời khuyên là dùng SHA-2 để thay thế. SHA-2 gồm các loại hashing algorithm được liệt kê bên trên.

## Random Number Generation

Random number generation được tích hợp trong nhiều cryptographic operations. Ví dụ, cryptographic keys cần random key và chắc chắn key đó không thể được tạo lại. Cryptographic random number generation bắt buộc phải tính toán output sao cho không thể dự đoán được. Do đó, bấy kỳ phương thức dự đoán output tiếp theo cũng không thể thực hiện tốt hơn dự đoán random. Trong .NET những classes sử dụng random number generators để tạo cryptographic keys.

Random Number Generator class dùng để thực hiện random number generator algorithm

## ClickOnce Manifests (Bảng kê khai)

Những cryptography classes sau, bạn có thể lấy (obtain) và xác nhận (verify) thông tin về manifest signature dành cho ứng dụng được triển khai sử dụng [ClickOnce technology](https://learn.microsoft.com/en-us/visualstudio/deployment/clickonce-security-and-deployment?view=vs-2022)

- **ManifestSignatureInformation** class để lấy thông tin (obtain information) về một manifest signature, sau đó bạn overloads phương thức **VerifySignature**.
- Bạn có thể sử dụng **ManifestKinds** enumeration với manifests để verify. Kết quả của verification là một **SignatureVerificationResult** enumeration values. 
- **ManifestSignatureInformationCollection** class cung cấp một *read-only collection* của **ManifestSignatureInformation** objects của verified signatures.

Hơn nữa, các classes bên dưới cung cấp chính xác signature information:

- **StrongNameSignatureInformation** nắm giữ thông tin strong name signature của một manifest.
- **AuthenticodeSignatureInformation** miêu tả Authenticode signature information của manifest.
- **TimestampInformation** chứa thông tin về time stamp trong Authenticode signature.
- **TrustStatus** cung cấp một cách đơn giản để check một Authenticode signature là đúng.

## Cryptography Next Generation (CNG) Classes

Cryptography Next Generation (CNG) classes cung cấp một managed wrapper around the native CNG functions. (CNG là sự thay thế của CryptoAPI). Classes có "Cng" là môt phẩn của chúng. Trung tâm của CNG wrapper classes là **CngKey**, key chứa trong class, với abstracts the storage và sử dụng CNG keys. Class này bạn có thể lưu trữ một key pair or một pubic key securely và suy ra (refer) nó đã được sử dụng một simple string name. Đường công cơ bản elip (The elliptic curve-base) **ECDsaCng** signature class và **ECDiffieHellmanCng** encryption class có thể sử dụng **CngKey** objects

**CngKey** class được sử dụng rất đa dạng trong các hành động bổ sung (additional operations), bao gồm opening, creating, deleting, và exporting keys. Nó cung cấp việc truy cập (access) phía dưới lớp key handle khi calling native function directly.

.NET cũng bao gồm nhiều hỗ trợ đa dạng CNG base, như sau:

- **CngProvider** maintains a key storage provider.
- **CngAlgorithm** maintains a CNG algorithm.
- **CngProperty** maintains frequently used key properties.

## Reference

https://learn.microsoft.com/en-us/dotnet/standard/security/cryptographic-services