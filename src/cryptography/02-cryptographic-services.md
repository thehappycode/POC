# Overview of encryption, digital signatures, and hash algorithms in .NET

Trong bài học hôm nay, chung ta sẽ overview các encryption methods và practices được hỗ trợ bởi .NET, gồm cả ClickOnce manifests.

## Introduction to cryptography

Pubic network là giao tiếp không được bảo vệ trên mạng internet. Việc giao tiếp trên networks rất dễ bị đọc hoặc chỉnh sửa bởi bên bên thứ ba (third parties). Cryptography giúp bảo vệ dữ liệu của người đọc (viewer), nhà cung cấp xác định được dữ liệu đã bị chỉnh sửa, và giúp việc giao tiếp trơ nên an toàn trên cả những kênh không được bảo vệ. Ví dụ, dữ liệu được mã hóa (encrypted) bằng cách sử dụng cryptographic algorithm, và dữ liệu đó được chuyển đi, sau đó được bên nhận giải mã (decrypted). Nếu third party chặn dữ liệu đã mã hóa, dữ liệu đó cũng khó biết được cách giả mã (decipher).

Trong .NET, những classes trong namespace `System.Security.Cryptography` quản lý việc cryptography của bạn. Đôi khi chúng được đóng gói (wrappers) triển khai trong hệ điều hành (OS), trong khi những classes khác sẽ bị quản lý việc triển khai. Bạn không cần phải là các chuyên già (expert) về cryptography mới có thể sử dụng được các classes này. Khi bạn tạo một new instance của một encryption algorithm classes, keys are autogenerated rất dễ để sử dụng, và các properties mặc định chắc chắc safe và secure.

## Cryptographic Primitives

Trong một tình huống nơi mà cryptography được sử dụng, có 2 bên (Alice và Bod) giao tiếp với nhau trên một kênh nosecure. Alice và Bob muốn đảm bảo (ensure) bất kỳ ai khác lắng nghe (listening) cũng không thể hiểu được. Bởi vì Alice và Bob đang giao tiếp từ xa (remote locations), Alice muốn chắc chắn thông tin cô ấy nhận từ Bob đã không bị bất kỳ ai thay đổi (modifier) trong suốt quá trình trao đổi (transmission). Thêm nữa, cô ấy cũng muốn chắc thông tin đó là từ Bob chứ không phải đến từ bất kỳ người nào mạo danh Bob.

Crytography được sử dụng vì các mục đích sau:

- Confidentiality: Giúp bảo vệ danh tính người dùng (user's identity) hoặc dữ liệu đến khi được đọc.
- Data integrity: Giúp bảo vệ dữ liệu từ không bị thay đổi.
- Authentication: Đảm bảo dữ liệu gốc từ một bên cụ thể.
- Non-repudiation: Ngăn chặn một bên cụ thể từ chối thông điệp mà họ đã gửi.

Từ những mục đích trên, bạn có thể kết hợp sử dụng nhiều algorithms và practices bằng cryptographic primitives để tạo ra một cryptography scheme. Bảng bên dưới là danh sách các cryptographic primitives.

| Cryptographic primitive                         | Use                                                                                                                                                                                                            |
| :---------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Secret-key encryption (symmetric cryptography)  | Secret-key thực hiện việc chuyển đổi trên dữ liệu, giữ cho dữ liệu không thể bị đọc bởi third parties. Đây là kiểu mã hóa (encryption) sử dụng một sigle shared, secret-key dùng để encrypt và decrypt dữ liệu |
| Public-key encryption (asymmetric cryptography) | Public-key thực hiện việc chuyển đổi trên dữ liệu, giữ cho dữ liệu không thể bị đọc bởi third parties. Đây là kiểu mã hóa (encryption) sử dụng  một cặp public/private keys để encrypt và decrypt dữ liệu      |
| Cryptographic signing                           | Giúp xác nhận (verify) dữ liệu gốc từ chính xác một bên tạo bởi quá trình ký số (digital signature) duy nhất của bên đó. Quá trình sử lý sử dụng chức năng hash                                                |
| Cryptographic hashes                            | Ánh xạ dữ liệu (Maps data) có chiều dài bất kỳ luôn trả về một chuổi byte có chiều dài cố định. Hashes là duy nhất; Hai chuổi byte khác nhau sẽ không thể hash cùng một giá trị                                |

## Secret-Key Encryption

Secret-key encryption algorithms sử dụng một single secret key để encrypt và decrypt data. Bạn bắt buộc secure key, không được truy cập bởi unauthorized, bởi vì bất kỳ bên nào có key cũng có thể sử dụng để decrypt dữ liệu của bạn hoặc encrypt dữ liệu và tuyên bố đó là dữ liệu gốc từ bạn.

Secret-key encryption được quy vào là symmetric encryption bởi vì sử dụng cùng một key cho việc encryption và decryption. Secret-key encrytion algorithms rất nhanh (compared with public-key algorithms) và nó hoàn toàn tốt cho performing cryptographic transformations trên large streams of data. Asymmetric encrytion algorithms như RSA bị giới hạn bởi tính toán với lượng nhiều dữ liệu có thể encrypt. Symmetric encryption algorithms không tạo ra những vấn đề đó.

Secret-key algorithm mà một kiểu mã hóa khối (block cipher), nó được sử dụng để encrypt một block dữ liệu tại một thời gian. Block ciphers như Data Encryption Standard (DES), TripleDES, và Advanced Encryption Standard (AES) chuyển đổi một input block với  n bytes vào trong một output block của encrypted bytes. Nếu bạn muốn encrypt hoặc decrypt một chuổi bytes, bạn sẽ phải thực hiện từng block một. Bởi vì n nhỏ (8 bytes với DES và TripDES, 16 bytes [default], 24 bytes hoặc 32 bytes của AES), giá trị dữ liệu của một encrypted trên một block tại một thời gian sẽ lớn hơn n. Giá trị dữ liệu sẽ nhở hơn n khi ta tăng n trong quá trình xử lý.

Một simple của block cipher được gọi là electronic codebook (ECB) mode. ECB mode không bảo vệ nội dung, bởi vì nó không sử dụng initialization vector để khởi tạo một first plaintext block. Có một key k, một simple block cipher không sử dụng initialization vector khi encypt input block của plaintext vào trong output block khi mã hóa. Khi đó, nếu bạn duplicate blocks trong input plaintext stream của bạn, bạn sẽ có duplicate blocks in output cipertext stream. Khi duplicate output blocks thì các unauthorized users sẽ biết đây là weak encryption sử dụng algorithms, họ có thể tiến hành tấn công. ECB cipher mode rất dễ bị phân tích để khám phá key.

Block cipher classes được cung cấp trong base class library sử dụng default chaining mode được gọi là cipher-block chainning (CBC), bạn có thể thay đổi default này nếu bạn muốn.

CBC ciphers giải quyết hết các vấn đề của ECB ciphers bởi initialization vector (IV) để encrypt the first block of plaintext. Mỗi subsequence block của plaintext bên dưới sẽ thực hiện mã hóa kèm theo bitwise đã được mã hóa block trước đó. Mỗi một ciphertext block sẽ phụ thuộc vào tất cả các block trước đó. Nên khi sử dụng, những authorized user không thể sẻ dụng reverse-enginner một key.

Một cách để compromise data (lấy dữ liệu gốc) với mã hóa CBC cipher là thực hiện tìm kiếm toàn tất cả key. Điều này phụ thuộc vào kích thước của key khi sử dụng để thực hiện encryption, việc tìm kiếm tiêu tốn rất nhiều thời gian kể cả với những máy tính siêu nhanh. Kích thước key càng lớn thì càng khó để decipher và chi phí để giải mã càng cao nên gần như không khả thi trong thực tế.

Một bất lợi (disadvantage) của secret-key encryption là phải có sự đồng ý của hai bên về key và IV, và giao tiếp với 2 giá trị đó. IV sẽ có nội dung không bí mật và đùng để chuyển đổi plaintext với message. Tuy nhiên, key phải bắt buộc phải được giữ bí mật với unauthrized users. Bởi vì, key-secret encryption thường được dùng cùng với public-key encrytion để giao tiếp.

Giả sử Alice và Bob là 2 bên muốn giao tiếp với nhau trên kênh nosecure, họ sử dụng secret-key encryption theo luồng sau: Alice và Bob đồng ý sử dụng một algorithm (AES chẳn hạn) với một key và IV. Alice sẽ tạo một message và tạo một network stream (network email) để chuyển message. Tiếp theo, cô ấy sẽ encrypts text sử dụng key và IV, và chuyển encryption message và IV đến Bob trên mạng nội bộ. Bob nhận encrypted text và decrypts sử dụng IV và key đã thống nhất trước đó. Nếu trong quá trình chuyển, message bị chặn lại thì người chặn cũng không thể recover được message original, bởi vì họ không biết key. Trong kịch bản này, chỉ có key là được giữ bí mật. Trong thế giới thực, Alice và Bob sẽ tạo một secret key và sử dụng public-key (asymmetric) encryption và chuyển secret (symmetric) key đến bên khác. Thông tin về public-key encryption, sẽ được thấy trong mục tiếp theo.

.NET cung cấp classes để thực hiện secret-key encrytion algorithms sau:

- Aes
- HMACSHA256, HMACSHA384 và HMACSHA512

## Public-key Encryption

## Reference

https://learn.microsoft.com/en-us/dotnet/standard/security/cryptographic-services
