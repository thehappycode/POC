# Overview of encryption, digital signatures, and hash algorithms in .NET

Trong bài học hôm nay, chung ta sẽ overview các encryption methods và practices được hỗ trợ bởi .NET, gồm cả ClickOnce manifests.

## Introduction to cryptography

Pubic network là giao tiếp không được bảo vệ trên mạng internet. Việc giao tiếp trên networks rất dễ bị đọc hoặc chỉnh sửa bởi bên bên thứ ba (third parties). Cryptography giúp bảo vệ dữ liệu của người đọc (viewer), nhà cung cấp xác định được dữ liệu đã bị chỉnh sửa, và giúp việc giao tiếp trơ nên an toàn trên cả những kênh không được bảo vệ. Ví dụ, dữ liệu được mã hóa (encrypted) bằng cách sử dụng cryptographic algorithm, và dữ liệu đó được chuyển đi, sau đó được bên nhận giải mã (decrypted). Nếu third party chặn dữ liệu đã mã hóa, dữ liệu đó cũng khó biết được cách giả mã (decipher).

Trong .NET, những classes trong namespace `System.Security.Cryptography` quản lý việc cryptography của bạn. Đôi khi chúng được đóng gói (wrappers) triển khai trong hệ điều hành (OS), trong khi những classes khác sẽ bị quản lý việc triển khai. Bạn không cần phải là các chuyên già (expert) về cryptography mới có thể sử dụng được các classes này. Khi bạn tạo một new instance của một encryption algorithm classes, keys are autogenerated rất dễ để sử dụng, và các properties mặc định chắc chắc safe và secure.

## Cryptographic Primitives

Trong một tình huống nơi mà cryptography được sử dụng, có 2 bên (Alice và Bod) giao tiếp với nhau trên một kênh nosecure. Alice và Bob muốn đảm bảo (ensure) bất kỳ ai khác lắng nghe (listening) cũng không thể hiểu được. Bởi vì Alice và Bob đang giao tiếp từ xa (remote locations), Alice muốn chắc chắn thông tin cô ấy nhận từ Bob đã không bị bất kỳ ai thay đổi (modifier) trong suốt quá trình trao đổi (transmission). Thêm nữa, cô ấy cũng muốn chắc thông tin đó là từ Bob chứ không phải đến từ bất kỳ người nào mạo danh Bob.

Crytography được sử dụng vì các mục đích sau:

- Confidentiality: Giúp bảo vệ danh tính người dùng (user's identity) hoặc dữ liệu đến khi được đọc.
- Data integrity: Giúp bảo vệ dữ liệu từ không bị thay đổi.
- Authentication: Đảm bảo dữ liệu gốc từ một bên cụ thể.
- Non-repudiation: Ngăn chặn một bên cụ thể từ chối thông điệp mà họ đã gửi.

Từ những mục đích trên, bạn có thể kết hợp sử dụng nhiều algorithms và practices bằng cryptographic primitives để tạo ra một cryptography scheme. Bảng bên dưới là danh sách các cryptographic primitives.

| Cryptographic primitive                         | Use                                                                                                                                                                                                            |
| :---------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Secret-key encryption (symmetric cryptography)  | Secret-key thực hiện việc chuyển đổi trên dữ liệu, giữ cho dữ liệu không thể bị đọc bởi third parties. Đây là kiểu mã hóa (encryption) sử dụng một sigle shared, secret-key dùng để encrypt và decrypt dữ liệu |
| Public-key encryption (asymmetric cryptography) | Public-key thực hiện việc chuyển đổi trên dữ liệu, giữ cho dữ liệu không thể bị đọc bởi third parties. Đây là kiểu mã hóa (encryption) sử dụng  một cặp public/private keys để encrypt và decrypt dữ liệu      |
| Cryptographic signing                           | Giúp xác nhận (verify) dữ liệu gốc từ chính xác một bên tạo bởi quá trình ký số (digital signature) duy nhất của bên đó. Quá trình sử lý sử dụng chức năng hash                                                |
| Cryptographic hashes                            | Ánh xạ dữ liệu (Maps data) có chiều dài bất kỳ luôn trả về một chuổi byte có chiều dài cố định. Hashes là duy nhất; Hai chuổi byte khác nhau sẽ không thể hash cùng một giá trị                                |

## Secret-Key Encryption

Secret-key encryption algorithms sử dụng một single secret key để encrypt và decrypt data. Bạn bắt buộc secure key, không được truy cập bởi unauthorized, bởi vì bất kỳ bên nào có key cũng có thể sử dụng để decrypt dữ liệu của bạn hoặc encrypt dữ liệu và tuyên bố đó là dữ liệu gốc từ bạn.

Secret-key encryption được quy vào là symmetric encryption bởi vì sử dụng cùng một key cho việc encryption và decryption. Secret-key encrytion algorithms rất nhanh (compared with public-key algorithms) và nó hoàn toàn tốt cho performing cryptographic transformations trên large streams of data. Asymmetric encrytion algorithms như RSA bị giới hạn bởi tính toán với lượng nhiều dữ liệu có thể encrypt. Symmetric encryption algorithms không tạo ra những vấn đề đó.

Secret-key algorithm mà một kiểu mã hóa khối (block cipher), nó được sử dụng để encrypt một block dữ liệu tại một thời gian. Block ciphers như Data Encryption Standard (DES), TripleDES, và Advanced Encryption Standard (AES) chuyển đổi một input block với  n bytes vào trong một output block của encrypted bytes. Nếu bạn muốn encrypt hoặc decrypt một chuổi bytes, bạn sẽ phải thực hiện từng block một. Bởi vì n nhỏ (8 bytes với DES và TripDES, 16 bytes [default], 24 bytes hoặc 32 bytes của AES), giá trị dữ liệu của một encrypted trên một block tại một thời gian sẽ lớn hơn n. Giá trị dữ liệu sẽ nhở hơn n khi ta tăng n trong quá trình xử lý.

Một simple của block cipher được gọi là electronic codebook (ECB) mode. ECB mode không bảo vệ nội dung, bởi vì nó không sử dụng initialization vector để khởi tạo một first plaintext block. Có một key k, một simple block cipher không sử dụng initialization vector khi encypt input block của plaintext vào trong output block khi mã hóa. Khi đó, nếu bạn duplicate blocks trong input plaintext stream của bạn, bạn sẽ có duplicate blocks in output cipertext stream. Khi duplicate output blocks thì các unauthorized users sẽ biết đây là weak encryption sử dụng algorithms, họ có thể tiến hành tấn công. ECB cipher mode rất dễ bị phân tích để khám phá key.

Block cipher classes được cung cấp trong base class library sử dụng default chaining mode được gọi là cipher-block chainning (CBC), bạn có thể thay đổi default này nếu bạn muốn.

CBC ciphers giải quyết hết các vấn đề của ECB ciphers bởi initialization vector (IV) để encrypt the first block of plaintext. Mỗi subsequence block của plaintext bên dưới sẽ thực hiện mã hóa kèm theo bitwise đã được mã hóa block trước đó. Mỗi một ciphertext block sẽ phụ thuộc vào tất cả các block trước đó. Nên khi sử dụng, những authorized user không thể sẻ dụng reverse-enginner một key.

Một cách để compromise data (lấy dữ liệu gốc) với mã hóa CBC cipher là thực hiện tìm kiếm toàn tất cả key. Điều này phụ thuộc vào kích thước của key khi sử dụng để thực hiện encryption, việc tìm kiếm tiêu tốn rất nhiều thời gian kể cả với những máy tính siêu nhanh. Kích thước key càng lớn thì càng khó để decipher và chi phí để giải mã càng cao nên gần như không khả thi trong thực tế.

Một bất lợi (disadvantage) của secret-key encryption là phải có sự đồng ý của hai bên về key và IV, và giao tiếp với 2 giá trị đó. IV sẽ có nội dung không bí mật và đùng để chuyển đổi plaintext với message. Tuy nhiên, key phải bắt buộc phải được giữ bí mật với unauthrized users. Bởi vì, key-secret encryption thường được dùng cùng với public-key encrytion để giao tiếp.

Giả sử Alice và Bob là 2 bên muốn giao tiếp với nhau trên kênh nosecure, họ sử dụng secret-key encryption theo luồng sau: Alice và Bob đồng ý sử dụng một algorithm (AES chẳn hạn) với một key và IV. Alice sẽ tạo một message và tạo một network stream (network email) để chuyển message. Tiếp theo, cô ấy sẽ encrypts text sử dụng key và IV, và chuyển encryption message và IV đến Bob trên mạng nội bộ. Bob nhận encrypted text và decrypts sử dụng IV và key đã thống nhất trước đó. Nếu trong quá trình chuyển, message bị chặn lại thì người chặn cũng không thể recover được message original, bởi vì họ không biết key. Trong kịch bản này, chỉ có key là được giữ bí mật. Trong thế giới thực, Alice và Bob sẽ tạo một secret key và sử dụng public-key (asymmetric) encryption và chuyển secret (symmetric) key đến bên khác. Thông tin về public-key encryption, sẽ được thấy trong mục tiếp theo.

.NET cung cấp classes để thực hiện secret-key encrytion algorithms sau:

- Aes
- HMACSHA256, HMACSHA384 và HMACSHA512

## Public-key Encryption

Public-key encryption sử dụng một `private key` bắt buộc phải giữa bí mật để để authentication users và một `public key` có thể public cho bất kỳ ai. Public key và private key có sự quan hệ (linked) về mặt toán học; data khi đã encrypted với public key chỉ có thể được decrypted với private key, và data được signed với private key thì chỉ có thể verified với public key. Public key có thể được cung cấp cho bất kỳ ai; nó được sử dụng dể encrypting data và chuyển đến người nắm giữ private key. Public-key cryptographic algorithms còn được biết đến là asymmetric algorithms bởi vì nó yêu cầu 1 key để encrypt data và yêu cầu môt key khác để decrypt data. Một quy tắc basic cryptographic là cấm (prohibits) là tái sử dụng key, và cả 2 keys phải là duy nhất trong mỗi communication session. Tuy nhiên, khi thực hành, asymmetric keys được tạo với thời gian sống rất lâu (long-lived).

Có hai bên (Alice và Bob) sử dụng public-key encryption như sau: Trước tiên, Alice tạo một cặp public/private key. Nếu Bob muốn chuyển đến Alice một encrypted message, anh ấy sẽ hỏi `public key` của cô ấy. Alice chuyển Bob `public key` của cô áy trên mạng nosecure network, và Bob sử dụng `public key` này để encrypt một message. Bob sẽ chuyển encrypted message sang cho Alice, và cô ấy sẽ decryptes nó bằng cách sử dụng `private key` của cô ấy. Nếu Bob nhận key của Alice trên kênh nosecure chanel, như public network, Bob có thể sẽ bị một cuộc tấn công trung gian (Bob is open to a man-in-the-middle attack). Khi đó, Bob bắt buộc phải xác nhận (verify) với Alice là anh ấy đã copy đúng `public key` của cố ấy.

Trong suốt quá trình trao đổi `public key` của Alice, một unauthorized agent (đại lý, tác nhân) có thể chặn để láy `public key`. Hơn nữa,  agent này cũng chặn encrypted message từ Bob. Tuy nhiên, agent không thể decrypt the message với public key. The message chỉ có thể được decrypted chỉ duy nhất với `private key` của Alice, mà `private key` này ko được trao đổi. Alice cũng không được sử dụng `private key` để encrypt một reply message và chuyển đến Bob, bời vì bấy kỳ ai với `public key` cũng có thể decrypt message. Nếu Alice muốn chuyển một message để phản hồi Bob, thì cô ấy sẽ hỏi Bob `public key` của anh ấy và encrypts message của cô ấy với `public key` của Bob. Khi đó Bob sẽ dùng `private key` của mình để decrypt message từ Alice.

Trong kịch bản (scenario) này, Alice và Bob sử dụng public-key encryption để trao đổi môt secret key (symmetric) và sử dụng secret-key encryption trong suốt session còn lại.

Đây là danh sách so sách chính thức giữa public-key và secret-key cryptgraphic algorithms

- Public-key cryptographic algorithms được sử dụng để **fix buffer size**, trong khi secret-key cryptographic algorithms được sử dụng để **variable-length buffer**.

- Public-key algorithms không thể sử dụng chain data cùng nhau trong streams trong khi secret-key thì có thể, bởi vì chỉ số lượng nhỏ data có thể được encrypted. Do do, asymmetric operations cũng không được sử dụng với các streaming model giống như symmetric operations.

- Public-key encryption có số lượng keyspace (khoảng giá trị của key) lớn hơn nhiều so với secret-key encryption. Do do, public-key encryption khó có thể bị tấn công bằng cách thử cố gắng vét cạn key.

- Public key dễ dàng sử dụng trong hệ thống phân tán, bởi vì chúng ta không cần phải bảo vệ, và có thể cung cấp key cho bất kỳ ai.

- Một số public-key algorithms (RSA và DSA, nhưng không phải Diffie-Hellman) được dùng để tạo digital signatures và có thể xác nhận (verify) được người gủi data.

- Public-key algorithms sẽ rất chậm (very slow) khi so sánh với secret-key algorithms, và nó không được designed để encrypt số lượng lớn data. Public-key algorithms chỉ hửu ích trong việc trao đổi số lượng nhỏ data. Như trường hơp, public-key encryption được dùng để encrypt key và `IV` của secret-key algorithm. Sau đó key và `IV` được trao đổi, secret-key encryption sử dụng trong suốt session còn lại.

.NET cung cấp các classes sau để thực hiện public-key algorithms:
- RSA
- ECDsa
- ECDiffieHellman
- DSA

RSA cho phép encryption và signing, nhưng DSA chỉ có thể được sử dụng trong signing. DSA nó không an toán bằng RSA, và lời khuyên của chúng tôi là dùng RSA. Diffie-Hellman có thể chỉ được sử dụng khi tạo key (key generation). Nhìn chung, public-key algorithms có nhiều giới hạn hơn trong việc chúng ta sử dụng private-key algorithms.

## Digital Signatures

## Reference

https://learn.microsoft.com/en-us/dotnet/standard/security/cryptographic-services
